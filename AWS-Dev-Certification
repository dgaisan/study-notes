IAM 
	- IAM Allows you to manage users, groups, and roles and their corresponding level of access to the AWS Platform 
	- Policy is a JSON document which defines one or more permissions
		- policies control roles’ permissions 	

	- Enable MFA
		- Add a device
			- Authenticator App
				- Authy, Google Authenticator, Duo Mobile, etc…
				- Once the app is added the scan generated QR code to open on your device
				- To complete device registration enter first 2 codes generated by the app on your device
			- Security Key (YUBI Key) 
				- it’s like a usb drive
			- Hardware TOPT (Time-based One-time password)
	- Users
		- Add user
		- 2 types of access
			- Programmatic: AWS API, CLI, SDK, dev tools
			- AWS Management Console
		- Permissions
			- Add user to a group or a create a group
			- Copy permissions from existing user
			- Attach permissions directly to a user
	- Account Settings
		- Change password policy (set of rules for passwords)
			- password length
			- expiration days
			- require at least one lowercase
			- require at least one uppercase
			- require at least one number
			- require at least one non-alphanumeric
			- prevent password reuse
			- allow users to change their own password 
	- Roles
		- Secure way to grant permissions to entities that you trust
		- Roles are preferred from a security perspective
		- Key aspects and use cases
			- IAM: used to assign permissions to AWS resources, allowing users or services to access and manage those resources
			- Service-to-Service auth: Allow one to securely access and interact with another service w/o need for explicit access keys or long-term credentials 
			- Cross-Account-Access: enable entities from one AWS account to assume a role in another account. Useful when multiple AWS accounts need to collaborate or share resources securely 
			- Federation: enables users authenticated externally (social auth) to assume AWS roles and access AWS resources
			- EC2 instance profiles: roles are assigned to EC2 instances using instance profiles. This allows EC2 instances to automatically authenticate, granting necessary permissions to access other AWS resources 
		- examples of entities
			- IAM user in another account
			- app code running on EC2 instance that needs to perform actions on AWS resource
			- aws service that needs to act on resources in your account to provide its features
		- IAM roles issue keys that are valid for short durations, making them more secured way to grand access		- When attaching a role to EC2, the attached role grants access keys
			- aws configure list (will show access keys when role is attached, and there will be no keys when role is detached)

	- Testing IAM permission
		- IAM policy simulator 
			- Allows testing the effects of IAM policies before committing them to prod
			- validate that the policy works as expected
			- test policies attached to existing users, groups, roles
			- https://policysim.aws.amazon.com
	- When changing permissions on a running instance , the updated permission take effect almost immediately  
	- When provisioning and EC2 instance an Availability zone must be chosen 
		

EC2
	- Secure, resizable compute capacity in the cloud
	- it’s like a VM, only hosted in AWS
	- pay only for what you use (pay-as-you-go model)
	- Servers up and running in minutes

	- Pricing options 
		- On demand (default)
			- pay by an hour or a second depending on type of instance being run
			- low cost, and flexibility w/o upfront payment or long-term commitment
			- great for apps with short term, spiky or unpredictable workloads
			- good for “testing the water”
		- Reserved Instances
			- reserved capacity for 1 or 3 years.
			- comes with up to 72% discount on the hourly charge
			- Regional
			- Great for apps 
				- with predictable usage patterns
				- with specific capacity requirements 
			- allows paying upfront to reduce cost even further
			- types
				- standard RIs (up to 72% off on-demand price; however once it’s reserved it can’t be changed)
				- convertible RI’s (up to 54% off on-demand price; options to change to different RI of equal or greater value)
				- scheduled RI’s (Lunch within defined time window; match capacity reservation to predictable recurring schedule that only requires a fraction of a day, week, month)
		- Spot 
			- allows purchasing of unused capacity at a discount of up to 90%
			- prices fluctuate with supply & demand
			- user sets maximum price willing to pay, so the instance is in use only if the price doesn’t exceed the max price, otherwise it gets terminated
			- Good for apps with flexible start/end time, and for apps that are only feasible at very low compute prices
		- Dedicated
			- a physical EC2 server dedicated for your use
			- most expensive option
			- good for meeting compliance requirements
			- can be purchased on-demand or as reserved instance (with a discount)
		- calculator.aws

	- Instance types
		- Instance type determines the hardware of the host computer used for your instance
		- each type offers different compute, memory & storage capabilities 
		- grouped together in instance families

	- Security groups
		- basically a firewall
		- 

EBS Volumes (Elastic Block Store)
	- Storage volumes that can be attached to EC2 instances (basically disks)
	- Highly available and scalable storage volumes
	- When EC2 is lunched, at least 1 EBS volume gets attached to it. This where OS is installed
	- More volumes can be added
	- Can be used to install applications, run a database, store data
	- EBS volumes are Highly available: Automatically replicated within a single AZ to protect agains hardware failures
	- Scalable: dynamically increase capacity and change the type of volume with no downtime or performance impact to live systems 

	- EBS Volume types
		- General purpose SSD (gp2)
			- balance of price and performance 
			- 3 IOPS(I/O operations per second) per GiB, up to 16000 IOPS per volume 
			- gp2 that are smaller than 1 TB can burst up to 3000 IOPS
			- Good for boot volumes, development and test apps which are not latency sensitive
		- General purpose SSD (gp3)
			- latest generation
			- baseline of 3000 IOPS for any volume size (1GB - 16BG)
			- Delivering up to 16000 IOPS
			- 20% cheaper that gp2
			- just like gp2 gp3 is great for boot volumes, development and test apps which are not latency sensitive
		- Provisioned IOPS (io1)
			- the high performance option, and the most expensive 
			- up to 64000 IOPS per volume
			- 50 IOPS per GiB
			- use if needed more that 16000 IOPS for your app
			- designed for I/O intensive apps, large databases, and latency sensitive workloads 
		- Provisioned IOPS SSD (io2)
			- latest generation
			- Higher durability and more IOPS
			- io2 costs the same than io1
			- 500 IOPS per GiB
			- up to 64000 IOPS per volume
			- designed for 99.999% durability compared to other types which are 99.8% - 99.9%
			- designed for I/O intensive apps, large databases, and latency sensitive workloads 
		- Provisioned IOPS SSD io2 Block Express
			- SAN (Storage Area Network) in the cloud
			- Highest performance sub-millisecond latency 
			- underlying architecture is EBS Block Express - newest architecture
			- 4x thoughput and capacity of regular io2 volumes
			- up to 64TB
			- 256000 IOPS per volume 
			- 99.999% durability
			- Great for largest, most critical apps like SAP HANA, MS SQL Server, IBM DB2
		- Throughput Optimized HDD (st1)
			- hard disk drive (not ssd)
			- low  cost
			- great for storing large amounts of data
			- baseline throughput 40MB/s per TB
			- Ability to burst up to 250MB/s per TB
			- max thurput 500 mb/s per volume
			- frequently accessed, thruput intensive workloads
			- good for big data, data warehouses, ETL, and log processing
				- *ETL (Extract, Transform, and Load - process of combining data from multiple sources into large central repo called data warehouse)
		- Cold HDD (sc1)
			- lowest cost option
			- Baseline thruput of 12 Mb/s per TB
			- Ability to burst up to 80 MB/s per TB
			- Max thruput of 250MB/s per volume
			- 
	- IOPS vs Throughput 
		- IOPS
			- measures the number of read and write operations per second 
			- important metric for quick transactions, low latency apps, transactional workloads
			- Choose Provisioned (io1, io2) when need great performance for apps
			- 
		- Thoughtput 
			- measures number of bits read/write per second
			- Important metrics for large datasets, large I/O sizes, complex queries 
			- ability to deal with large datasets
			- Choose st1 when the apps requires dealing with large datasets
			
	- Encryption
		- if encryption by default is set on the account, then unencrypted EBS volume can’t be created
		- if EBS volume is being created from an encrypted snapshot, then the volume will end up being encrypted as well
		- if creating a volume from unencrypted snapshot then an encryption is only an option (unless account is encrypted) 

	- lsblk (list blocks)
	- mkfs -t ext4 /dev/xvdf (format attached volume/device in ext4)
	- mount /dev/xvdf /mnt/myvolume
	- df (report file system disk space usage)
			

Elastic load balancer
	- Load Balancer distributes network traffic across a group of servers
	- Load balancer will stop sending traffic to servers that fail, and will send traffic to those servers again only when they are back online
	- Application Load Balancer
		- balances HTTP/HTTPS traffic 
		- operate at Layer7 and are app-aware
		- support advanced request routing to specific web servers based on HTTP header
	- Network Load Balancer
		- Balances TCP traffic
		- High performance option
		- operates at Layer4 of OSI model
		- Capable of handling millions of requests per second
		- most expensive option
	- Classic Load Balancer
		- Handles HTTP/HTTPs and TCP 
		- Legacy option
		- not fastest, and doesn’t have best features
		- support some Layer7 features such as x-Forwarded-For headers and sticky sessions
			- sticky sessions (a technique used in load balancing that ensures that a client’s requests are constantly routed to the same backend server during a session) 
		- 
	- Gateway Load Balancer
		- newer offering
		- allows to load balance workloads for 3rd party virtual appliances purchased on marketplace

	- x-Forwarded-For
		- Identify the originating IP address of a client connecting thru a load balancer
	- Common errors
		- 504 (Gateway timeout) - target server failed to respond
			- first check application web server, DB, or lambda
			- the app is having issues

	- Creating Application load balancer
		- create EC2 instances
		- Create Target Group
		- Add EC2 instances to Target Group
		- Assign created target group to Load Balancer


Route53
	- Allows map a domain name that you own to EC2 instances, Load Balancers, S3 buckets
	- Hosted zone: a container for DNS records
	- A-record - an alias to a domain name

AWS CLI
	- pagination
		- by default AWS CLI uses a page size of 1000
		- the number of items included in output can be controlled 
		- “timeout” or “timed out” error might occur sometimes because API call exceed the maximum wait time
			- to fix use --page-size option to request smaller number of items from each API call
			- it will make multiple API calls to retrieve data but the display it all at once
	- aws s3api list-objects --bucket <bucket_name> --page-size 100
	- aws s3api list-objects --bucket <bucket_name> --max-page 50 (will return first 50 items, instead of all of them)

CloudShell
	- Linux terminal that provides access to a range of preinstalled tools
	- Run AWS CLI commands
	- ll /usr/local/bin (list of preinstalled apps/tools)

RDS (Relational Database Service)
	- in relational databases
		- data is organized in Tables
		- rows represent items 
		- fields in the database are columns
	- RDS is generally used for Online Transaction Processing (OLTP) workloads
	- Supported engines
		- MS Sql Server
		- Oracle 
		- MySQL
		- Postgres
		- MariaDB
		- Amazon Aurora
			- mysql & postgres compatible 
			- a lot more performant
			- it scales automatically
			- big improvement for MySQl and Postgres)
			- up & running in minutes
			- multi AZ failover capability
			- automated backups 
	- OLTP (Online Transaction Processing)
		- Processes data from transactions in real time (customer orders, banking transactions, payments, booking systems)
		- All about data processing and completing large data processing in real time
		- RDS not suitable for analyzing large data of data (use RedShift instead)
	- OLAP (Online Analytics Processing)
		- Process complex queries to analyze historical data (analyzing net profits for past 3 years, forecast sales)
		- All about data alalysis 
		- require different solutions than OLTPs
	- MySQl
		- Using availability and durability options we can create standby instances (either instances or clusters) in different AZs 
		- install mysql client on EC2 to be able to connect to the MySQL server: dnf install mariadb105
		- mysql -u admin -p -h  https://dimondb.c1hffolazafu.us-east-1.rds.amazonaws.com/ dimondb

	- Multi AZ
		- provides resilience and keep the app running if there’s failure on primary instance
		- exact copy of production database in another availability zone
		- primary RDS instance + standby/secondary RDS instance in a different AZ. 
		- Primary will copy/replicate data from primary to standby
		- standby is not visible to the app, but if primary fails then RDS autmatically will failover to a standby instance 
		- All DB types can be set as multi AZ
		- it’s useful for disaster recovery and NOT for improving performance
	- Read replicas
		- great for heavy workloads and used to increase/scale read performance 
		- read-only copy of primary DB
		- Read replicas can be cross AZs, or even cross region
		- each replica has its own endpoint	
		- can be promoted to its own database (not synched/connected with primary databases)
		- requires automatic backups
		- Multiple read replicas are supported - up to 5 read replicas for each instance

	- backups & snapshots
		- Snapshots
			- Manual, adhoc and user initiated - point in time copy of storage attached to an instance
			- stored in S3
			- no retention period
			- Allow backing up data to a known state
			- 
		- Automated backups
			- enabled by default
			- create backups/snashots automatically that run during a specific time window
			- transaction logs are used to replay transactions 
			- retention period of 1-35 days
			- point-in-time recovery
				- recovers database to any point of in time within retention period
				- was will select most recent backup + apply transaction logs to restore data to specific point of time
			- snapshots are stored in S3
			- free storage equal to the size of Database
			- during backup window I/O might be suspended for a few seconds, may experience increased latency
		- * when restoring RDS Database the restored version will always be a new RDS instance with a new DNS endpoint
		- Encryption at rest
			- can be enabled during creation time from the console
			- integrated with KMS (AES-256 encryption)
			- will encrypt all snapshots, read replicas, logs, … everything 
			- NOT POSSIBLE to encrypt existing database - use snapshots to encrypt: 
				- take an unencrypted snapshot
				- from this snapshot, create encrypted snapshot
				- restore DB from an encrypted snapshot	


	- RDS Proxy
		- Managed database proxy service 
		- increased scalability 
		- RDS proxy sits between client and the DB server
		- pools and shares database connections to assist with app scalability and db efficiency 
		- scales automatically by pooling established db connections instead of creating new ones
		- preserves application connections during failover
			- detects a failover and route requests to standby instance quickly
		- deployable over multi AZ for protection again infra failure
		- up to 66% faster failover time
		- 

Elasticache
	- in-memory cache
	- key-value data store
	- makes it easy to deploy, operate and scale in-memory cache
	- improves database performance - allowing to retrieve info from fast in-memory data rather than from a disk
	- useful for storing session data for distributed apps
	- frequently accessed data is stored in elastic cache 
	- useful when app is under heavy read
	- doesn’t help a lot when database is under heavy write stress
	
	- types
		- memcached
			- great for basic object caching
			- scales horizontally but there’s no persistence?
			- no multi AZ, no failover
			- good choice for basic caching (when caching models that are as simple as possible)
		- Redis
			- more sophisticated solution
			- supports persistance, replication, multi-AZ, failover
			- support sorting and ranking data (for example gaming leaderboards)
			- supports complex data types like lists and hashes

	Typical scenario
		- A database is under a lot of stress

	- MemoryDB for Redis
		- Massively scalable in-memory Database 
		- scalable Gb’s to 100+ TB
		- highly available, multi AZ, transaction log for recovery and durability
		- can be used as primary database (instead of traditional database)
		- ultra fast performance, support > 160 million requests per second, 
		- microsecond read and single-digit millisecond write latency
		- great for 
			- workloads requiring an ultra-fast, redid compatible primary database
			- applications that need an in-memory database to handle millions of requests per second
			- data intensive apps, that require scalability 
		- use case
			- an online gaming company needs a way for millions of concurrent users to generate interactive 3D digital worlds and share digital assets

Parameter store (Systems Manager)
	- stores parameters used by application
		- license keys, database keys, database connection info, usernames, passwords, etc..
	- this information can be passed to EC2 instances as a bootstrap script
	- can be passed to lambda, or via cloudformation, or some other services

Secrets manager
	- allows protecting and storing secrets
	- used to access resources inside and outside AWS
	- Rotation automation 
	- secrets with control of fine-grained permissions and encryption with KMS
	- types of secrets
		- RDS database secrets
			- MySQL, Postgrees, Sql Server, Oracle : database username, password, server address, DB name, DB port
		- Redshift cluster
		- DocumentDB database
		- other DB’s
		- API keys
	- encrypted using AWS KMS
		- uses CMK
		- 
	- best practice to configure Automatic Rotation of Secrets
		- every 30, 60, 90, or custom days
	- create new or use existing Lambda for secrets rotation

Secrets Manager vs Systems Manager (parameter store)
	- Secrets Manager
		- Database credentials
		- API keys
		- Rotation of Keys
	- Parameter Store
		- Wider set of use cases
		- Configuration variables
		- License Keys

EC2 Image Builder
	- allows creating and automating Virtual Machine Images (AMIs) and container images
	- graphical interface
	- validate images 
	- allows sharing AMIs with other AWS accounts
	
	- process
		- provide base OS
		- define software that we want to install (ex. Python, latest kernel, etc)
		- Test (run tests on new image, it spins up new EC2 instance and run the tests)		- distribute image to region of your choice

	- image pipeline (defines configs and e2e process of building image)
		- recipe, distribution, test settings
	- Image recipe 
		- source image (ex MacOS)
		- build components (apache server)
	- build components (software included into the image)

	- Copy AMI
		- Unencrypted AMI can be copied to encrypted AMI
		- Encrypted AMI can be copied to encrypted AMI
		- Unencrypted AMI can be copied to encrypted AMI (option to add a copy)
		- Encrypted AMI CANNOT be copied into unencrypted AMI
		- by default AMI is copied with its original status 
		- to use in a different region, create a copy and specify destination region!

S3
	- object storage
	- files, images, videos, docs, webpages, …
	- allows to store and retrieve any amount of data at low cost (unlimited storage)
	- it cannot be used to run OS or DB
	- objects can be up to 5TB in size
	- files are stored in buckets (similar to a folder)
	- universal namespace
		- all AWS account share same name space
		- must be globally unique
	- https://bucket-name/s3.Region.amazonaws.com/key-name (https://dimon1234/s3.us-east-1.amazonaws.com/myfile.jpg)
	- HTTP code 200 when a file was uploaded successfully 
	- key-value store
		- key - name of the object
		- value - data itself (sequence of bytes)
		- versionID - stores different versions of same file/object
		- Metadata - data about data (contnt-type, last-modified, name of team, …)
	- data is available and durable 
		- data is spread across multiple devices and facilities
		- 99.95-99.99 service availability 
		- 99.999999(11 9’s) durability 
	- Tiered storage
	- lifecycle management 
		- define rules to delete object, or transmit them to a different store
		- with versioning all versions of an object stored can be retrieved, even deleted objects
	- Securing data
		- enbale/disable server side encryption
		- Access Control Lists (ACL)
			- define what groups and accounts are granted access and the type of the access
		- Bucket Policies
			- specify what actions are allowed/denied (allow someone to put but not delete an object into a bucket)
		- Enforce encryption with a bucket policy
			- Explicitly deny requests that don’t include x-amz-server-side-encryption param in request header
			- deny requests that do not use aws:SecureTransport to enforce the use of HTTPS/SSL
	
	- Storage classes
		- S3 standard
			- High availability and durability
			- data stored redundantly across multiple devices and multiple facilities
			- data is stored at least in 3 AZs
			- perfect for frequently accessed data
			- suitable for most workloads
			- default class
			- use cases: web, big data, gaming, content distribution …
		- S3 standard-infrequent access (S3-IA)
			- designed for infrequently accessed data
			- data is accessed on daily accessed
			- rapid access when needed
			- data is stored at least in 3 AZs
			- pay Per data access (low per-GB storage price + per-GB retrieval price)
			- minimum storage duration: 30 days
			- use cases: long term storage, backups, recovery files
		- S3 one zone-infrequent access 
			- just like S3-IA but data is stored redundantly within single AZ (instead multiple AZs)
			- not for critical data
			- cost effective (20% cheaper than S3-IA)
			- min duration 30 days
			- 99.5% availability
		- Glacier Flexible Retrieval
			- very cheap storage
			- optimized for data that infrequently accesses
			- pay pay access
			- should be used for archiving data
			- retrieval times 1min - 12 hours
			- good for historical data
			- minimum 90 days storage
		- Glacier instant retrieval
			- millisecond retrieval times
			- minimum duration 90 days
		- Glacier deep archive
			- default retrieval time 12 hours
			- great for storing fin records that maybe accessed once or twice per year
			- 180 days minimum storage duration
			- 99.99% availably and 99.99(11 9’s durability)
		- S3 inteligent tiering 
			- get 2 tiers: frequent and infrequent
			- automatically moves data to the most cost effective  tier based on  how frequently objected are accessed
			- optimized cost: added monthly fee 0f $0.0025 per 100 objects
			- 99.99% availably and 99.99(11 9’s durability)

		- costs
			- S3 Standard (most expensive)
			- S3 inteligent tiering
			- S3-IA, S3 one-zone, Glacier & Glacier deep archive (fee per retrieval)

	- Securing buckets
		- all newly created buckets are private by default
		- by default only a bucket owner can upload new files, read files, delete files, …
		- no public access by default
		
		- Bucket policies
			- allows setting up Access Control to buckets
			- applied at bucket level
			- permissions granted by a policy are granted to all object in a bucket
			- can’t attach a policy to an object
			- useful when need to provide access to a group of files within a bucket
			- policies are written in JSON
			- AWS has policy generator tool to build policies
		- Bucket ACL (Access Control Lists)
			- applied at object level
			- can apply different permissions for different objects within a bucket
			- define which accounts or groups are granted access and also type of access (read, write, full control)
			- fine grained access control
		- S3 access logs
			- not enabled by default
			- log activity 
			- logs can be written to another S3 bucket

	- Encryption
		- protecting data is security best practice
		- Encryption in Transit
			- using SSL/TLS
			- HTTPS (communication is encrypted)
		- Encryption at Rest (server side encryption)
			- SSE-S3 (S3 managed keys, using AES 256-bit encyption, enabled by default)
			- SSE-KMS (KMS managed keys)
			- SSE-C (customer provided keys, managed outside of AWS)
			- client-side encryption (files are encrypted before uploaded to S3)

	- CORS
		- Cross Origin Resource Sharing
		- Allow code in one S3 bucket to access code in another S3 bucket (allowing one resource to access another resource)
		- Add COR configuration via Permissions -> CORS
			- JSON config

	- S3 static website
		- use bucket to create static website (html, javascript, fonts, images,)
		- when creating a bucket for website make it public
		- enable static website for the bucket (Properties -> Static Website)
		- update bucket policy to actually make files public (Permissions -> Edit Bucket Policy)
			{ 
				"Version": "2012-10-17", 
				"Id": "Policy1645724938586", 
				"Statement": [ 
					{ 
						"Sid": "Stmt1645724933619", 
						"Effect": "Allow", 
						"Principal": "*", 
						"Action": "s3:GetObject", 
						"Resource": "<BUCKET_ARN>/*" 
					} 
				] 
			}
		- website Url format
			- http://<bucket-name>.s3-website-<region>.amazonaws.com
			- http://myindex-web010101-1.s3-website-us-east-1.amazonaws.com/


Cloudfront 
	- Allows caching content in edge locations
		- edge locations are separate from an AWS Region and AZ
	- Origin - the origin of all files that the distribution will serve 
		- can be S3 bucket, EC2 instance, ELB, Route53
	- Distribution
		- the origin and config settings for the content you wish to distribute using CloudFront (CDN)
	- Edge locations are not read-only, can write to them (put an object into them)
	- S3 transfer Acceleration
		- edge locations are utilized by S3 Transfer Acceleration to reduce latency for S3 uploads
	- Time to Live (TTL)
		- objects are cached for the life of TTL
		- cached objects can be cleared, comes with addiiotanl change
	- Allowed HTTP methods
		- GET, HEAD (readonly)
		- GET, HEAD, OPTIONS (readonly)
		- GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE (allow writing data)

		- for interactive website that need to allow users to write (forms, upload files, etc…) need to enable 3rd option 

Athena
	- enables to run SQL queries on data stored in S3
	- interactive query service
	- it’s serverless (nothing to provision)
	- pay per query per TB scan
	- use cases
		- analyze Trail logs
		- log files stored in S3 (ELB logs, s3 logs, )
		- cost analysis (AWS cost usage report)
		- generate business report on data in S3
		- Run queries on click-stream data 

	- usage
		- before using Athena, we need to create a bucket for it
		- setup query result location (bucket from previous operation) 
		- CREATE DATABASE athenadb (creates new database)
		- create table using SQL (define data attributes, and source location: buckets/<Bucket_NAME>/AWSLogs/<Account_Number>)
		- now it’s ready for queries data
			- SELECT 
				useridentity.arn,
				eventname,
				sourcesipaddress,
				eventtime
			  FROM
				cloudtraillogs
			  LIMIT 100
		

CloudTrail
	- generates an audit log of all activity on an account
	- creates an S3 bucket where it sends all the logs

KMS (Key management service)
	- Managed service that makes it easy to create and control the encryption keys used to encrypt your data
	- integrated with lots of different AWS services (s3, dynamo, lambda, rds, ebs, cloudtrail, dev tools)
	- Should be used when dealing with sensitive data (customer data, passwords, financial data, secrets, credentials)
	
	- CMK (Customer Master Key)
		- Encrypt/decrypt  data up to 4KB
		- used to generate/encrypt/decrypt data key (data key is used to encrypt/decrypt actual data)
		- typically permissions are given to admins or security teams
		- symmetric keys are used in conjunction with AWS access
		- KMS keys a created in single region, multi-region option is available
		- asymmetric keys can be used to encrypt/decrypt from outside of AWS/KMS
			- public - used to encrypt
			- private - apps will use this portion to decrypt
		- Key material
			- crypt secrets that make up the key
			- cloud HSM - next level service to KMS (own single tenant hardware - dedicated hardware for compliance environments)
		- create an alias - friendly name to identify the key
		- add description
		- key admin permissions
			- IAM users/roles that can administer (not use) key thru KMS
		- key sage permissions
			- IAM user/roles that can use they key to encrypt/decrypt data
	- AWS managed CMK
		- AWS provided CMK. 
		- Used on your behalf with AWS services integrated with KMS
	- Customer managed CMK
		- manually created keys
	- Data Key
		- Use CMK to generate/encrypt/decrypt data key
		- use Data key to encrypt/decrypt data

	- encrypt/decrypt via CLI
		- aws kms encrypt --key-id 5c12c55f-0051-4c5f-8376-4bb5b0a3ca4f --plaintext fileb://secret.txt --output text 
		- aws kms decrypt ….
		- aws kms re-encrypt … (takes encrypted file, decrypt it, encrypt again, and save to a different file: useful when want to encrypt something already encrypted using a different CMK)
		- aws kms enable-key-rotation <key_id> (AWS will rotate the key on annual basis)
		- aws kms get-key-rotation-status --key-id 5c12c55f-0051-4c5f-8376-4bb5b0a3ca4f (get rotation status)
		- aws kms generate-data-key --key-id <KEY_ID> --key-spec AES_256 (generate a data key for encrypting data target than 4KB)

	- Envelope encryption
		- a process for encrypting your data
		- it applies to files > 4KB
		- Encryption process
			- have a CMK in KMS
			- use GenerateDataKey API for generate Data Key (Envelope key)
			- envelope/data key is used to encrypt the data
			- Encrypted key is stored locally with the data so that it can be used later on for decryption
		- Decryption process
			- Use CMK from KMS and KMS API to decrypt envelope key.
			- Decrypt data using decrypted envelope key
			- Decrypted envelope key is deleted from memory
		- Why not encrypt using CMK directly?
			- the main reason is networking
			- only envelope key goes thru the network
			- Data is being encrypted/decrypted locally

	- Automatic key rotation
		- via console
		- KMS will rotate crypto material once a year
		- previous crypto materials will be saved, so that they can be used later for previously rotated data

	- ACM (AWS Certificate Manager)
		- Allows creating/managing public & private Secure Socket Layer(SSL)/Transport Layer Security(TLS) certificates
		- can be used with ELB, CloudFront, API Gateway, and web apps
		- SSL/TLS certificates 
			- digital certificates that used to verify the authenticity of a website
			- enable a secure connection between visitors and the website (HTTPS)
			- used during the encryption process to encrypt data in transit
		- Cloudfront does have a default certificate, but sometimes a custom one is needed
			- if need to use a non-default certificate than create a ACM certificate in   (only this region supports certificates in cloudfront) 


Serverless
	- enables to build scalable apps without managing any servers
	- Low cost
	- event driver, only charged when code is executed
	- no response is required In event driven environment
	- loosely coupled  systems can be built using SQS which allows to queue messages , and EventBridge which help with events and route them to app components
	- services and components are scalable and independent  
	
	- lambda
		- autoscale, event driven, pay only when ran
		- each event will tigger a single function
		- serverless along with APIGW, DynamoDB, S3, SNS, SQS
		- lambda can be triggered from: dynamodb, Dynamo, ALB, APIGW, Cloudfront, S3, CF, SNS, SES, Cloudwatch, Coecommit, CodePipeline, …

		- Execution role
			- a role that gives Lambda permission to do things within AWS account
			- for example to access s3 bucket, or access dynamodb
			- default execution role only allows writing logs to cloud watch

		- Versioning
			- $LATEST is always the latest version of code uploaded to lambda
			- use versioning and alias to point the app to a specific version of code (if don’t wanna use $LATEST)
			- example ARN
				- arn:aws:lambda:eu-west-2:19383284038:function:mylambda:Prod (alias)
				- arn:aws:lambda:eu-west-2:19383284038:function:mylambda:$LATEST (latest version of code)

		- Concurrent limit
			- 1000 concurrent executions per second, per region per account
			- When limit is hit, we’ll see invocation rejections (429 HTTP status code - too many requests)
			- limit can be raised by AWS support
			- for critical apps Reserved Concurrency can be used

		- VPCs & lambda
			- lambda can be enabled to access resource in a private VPC
				- Need to provide VPC config info to lambda function
					- VPC - specify VPC that function needs to access
					- Subnets: selects subnets that lambda needs to use
					- Security Groups
						- Security Group will allow the function to access resource in VPC 
				- Add Policy to allows lambda VPC access
				- lambda will use the information about VPC, Subnets, and Sec Groups to configure an ENI (Elastic Network Interface) using IP address from private CIDR range
			- use case example
				- lambda needs read/write access to an RDS database within a VPC
				- lambda needs to shut down an EC2 instance in response to a security alert


		- Ephemeral and Persistent Data Storage patterns
			- Lambda is stateless  (can’t permanently store data within lambda itself)
			- ephemeral - functions run for short period of time (15 min max)
			
			- Storage options
				- Native within Lambda 
					- /tmp
						- temporary storage
						- provided within exec env of lambda 
						- default 512 MB, configurable to up to 10 GB
						- like a cached file system 
						- data can be accessed by multiple function invocation sharing the execution environment 
						- Data is no Persistent, only available for the lifetime of execution environment 
						- assume that data is lost when execution is completed 
					- deployment package
						- additional libraries needed by function can be included in your Lambda deployment package (zip file containing code)
						- the downside is that it increases deployment package size (slower deployments) 
					- Lambda layers
						- best option (instead of deployment package)
						- add libs and SDKs as layer that can be referenced by multiple functions
						- great for large dependencies such as image manipulation libraries, graphics libraries, or a particular versions of SDKs
						- better performance, and deployment is faster
						- it’s not dynamic, need to create a new layer if want updates
						- 50 MB zipped, 250MB unzipped 
				- External options
					- S3
						- object storage
						- can’t append data to objects
						- to change data, need to upload new object
					- EFS
						- shared file system
						- based on NFS
						- data is persistent
						- can modify data (dynamic read/write)
						- should be mounted by the function when the execution environment is created 
						- can be shared across multiple invocations
						- only works within VPC 
					- RDS
					- Dynamo
		

	- API Gateway
		- provides a single endpoint for all traffic interacting with the backend of your app
		- front door to an app (to access data, business logic, functionality)
		- endpoint to a app running in AWS
		- low cost and scales automatically 
		- provides throttling, to prevent app from being overloaded by too many requests
		- Provides REST API and Websocket API
			- Rest API (Representation State Transfer)
				- stateless, optimized for serverless
				- supports JSON
		- APIW forwards the requests coming from a client over to a service(Lambda, EC2, DynamoDb, Kenesis, Beanstalk) depending on type of the request
		- Supports Multiple Endpoint
			- each API request can be send to a different target 
		- Support multiple versions of API
			- allows having multiple versions for development, testing, prod environment 
		- Integrates with Cloudwatch
			- everything logs API calls, latencies, error rates

		- APIGW caching
			- improve the performance of APIs by caching the output of API calls to avoid calling backend every time.
			- responses are cached for a TTL period. The default TTL is 300 seconds (5 mins)
			- reduces number of calls to an app (APIGW returned cached response)

		- APIGW throttling 
			- default limit 10000 req per second 5000 concurrent requests 
			- 429 - too many requests
			- aws support can increase limits

		- Advanced APIGW
			- own API can be imported  (OpenAPI, formerly Swagger)
			- when dealing with legacy apps which use SOAP, APIGW can be configured as SOAP  web service passthru, or convert XML responses to JSON

		- Mock endpoints
			- mimic the responses and behaviors of real API
			- define the response, provide status code and message

		- APIGW stages
			- Logical reference that references the lifecycle state of the API (dev, prod, v3, etc)
			- Each stage can be associated with different endpoint
				- each stage will have a unique invoke URL:
					- https://<API_ID>.execute-api.us-east-1.amazonaws.com/<STAGE>
					- https://xyz123.execute-api.us-east-1.amazonaws.com/dev
					- https://xyz123.execute-api.us-east-1.amazonaws.com/prod
				- different stages can send incoming requests to different functions


		- Request/Response transformations
			- APIGW can modify requests params before sending the request to the server 
				- can change header, querystring, request path
			- APIGW can modify response from the server before sending the response to the client 
				- append data, change status code, etc…


	- Step function
		- great way to visualize and orchestrate serverless applications 
		- automatically trigger and track each step of the State Machine or workflow
		- the output of one step is often an input of next step
	
		- workflows
			- standard workflow 
				- long running (up to 1 year) 
				- they run at most once
				- if run identical task then it will change the state (so only run once) = non-idempotent 
			- express workflows
				- short lives processes (up to 5 min)
				- run at least once
				- idempotent

				- there are 2 types of express workflows
					- sync
						- must compete before the next step begins
					- async
						- other tasks don’t depend on completion of other functions 

X-Ray
	- a tool which helps developers analyze and debug distributed applications
	- allows troubleshooting the root cause of performance issues and errors
	- checks performance bottlenecks 
	- provides visualization of your application’s underlying components
	- X-Ray Service Map provides an end-to end view of requests as they travel thru the application
		- collects HTTP status codes, latency, error message
		- used to troubleshoot connectivity problems
	- can be used with RC2, SQS, SNS, Dynamo, ELB, APIGW, ECS, Elastic beanstalk
	-  integrates with Java, .NET, nodejs, python, GO
	- monitors API calls, auto capture metadata for API calls made to AWS services using SDK
	- X-Ray architecture
		- install x-ray agent on EC2 instances
		- instrument apps using X-Ray SDK
		- Xray SDK gathers info from request and response headers, the code in the app, and metadata from AWS resources and sends the trace data to XRAY
		- for docker containers running on ECS cluster, X-ray agent/deamon should run in its own container
	- annotation
		- key/value pairs that record additional information about requests
		- use annotation for filtering   

